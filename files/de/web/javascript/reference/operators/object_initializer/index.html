---
title: Objekt Initialisierer
slug: Web/JavaScript/Reference/Operators/Object_initializer
tags:
  - ECMAScript 2015
  - JSON
  - JavaScript
  - Literal
  - Methods
  - Object
  - Primary Expression
  - computed
  - mutation
  - properties
translation_of: Web/JavaScript/Reference/Operators/Object_initializer
original_slug: Web/JavaScript/Reference/Operators/Objekt_Initialisierer
---
<div>{{JsSidebar("Operators")}}</div>

<p>Objekte können mit <a href="/de/docs/Web/JavaScript/Reference/Global_Objects/Object">new Object()</a>, <a href="/de/docs/Web/JavaScript/Reference/Global_Objects/Object/create">Object.create()</a>, oder mit der <em>literal</em> Notation (<em>Initialisierungs</em> Notation) initialisiert werden. Ein Objekt Initialisierer ist eine Komma getrennte Liste von null oder mehreren Paaren von Eigenschafts-Namen und zugehörigen Werten eines Objektes, eingeschlossen in geschwungene Klammern (<code>{}</code>).</p>

<div>{{EmbedInteractiveExample("pages/js/expressions-objectinitializer.html")}}</div>



<h2 id="Syntax" name="Syntax">Syntax</h2>

<pre class="brush: js">var o = {};
var o = { a: "foo", b: 42, c: {} };

var a = "foo", b = 42, c = {};
var o = { a: a, b: b, c: c };

var o = {
  <var>property: function </var>([<var>parameters</var>]) {},
  get <var>property</var>() {},
  set <var>property</var>(<var>value</var>) {},
};
</pre>

<h3 id="Neue_Schreibweisen_in_ECMAScript_2015">Neue Schreibweisen in ECMAScript 2015</h3>

<p>Man sollte in der Kompatibilitätstabelle die Unterstützung dieser Schreibweisen nachschlagen. In Umgebungen, die diese nicht unterstützen, entstehen Syntaxfehler.</p>

<pre class="brush: js">// Kurzschreibweisen für Eigenschaftsnamen (ES2015)
var a = "foo", b = 42, c = {};
var o = { a, b, c };

// Kurzschreibweise Methoden Namen (ES2015)
var o = {
  <var>property</var>([<var>parameters</var>]) {}
};

// Berechnete Eigenschaftsnamen (ES2015)
var prop = "foo";
var o = {
  [prop]: "hey",
  ["b" + "ar"]: "there",
};</pre>

<h2 id="Description" name="Description">Beschreibung</h2>

<p>Ein Objekt Initialisierer ist ein Ausdruck welcher die Initialisierung eines {{jsxref("Object")}} beschreibt. Objekte bestehen aus Eigenschaften, welche verwendet werden, um ein Objekt zu beschreiben. Die Werte der Objekt Eigenschaften können {{Glossary("primitive")}} Datentypen oder andere Objekte enthalten.</p>

<h3 id="Objekte_erzeugen">Objekte erzeugen</h3>

<p>Ein leeres Objekt ohne Eigenschaften kann wie folgt erzeugt werden:</p>

<pre class="brush: js">var object = {};</pre>

<p>Jedoch: die Vorteile der literalen oder Initialisierer Notation versetzen Sie in die Lage, Objekte inklusive Eigenschaften, innerhalb geschwungener Klammern, schneller zu erzeugen. Sie schreiben einfach eine Liste von Schlüssel:Werte Paaren, getrennt durch ein Komma. Der folgende Quellcode erzeugt ein Objekt mit drei Eigenschaften mit den Schlüsseln <code>"foo"</code>, <code>"age"</code> und <code>"baz"</code>. <span id="result_box" lang="de"><span>Die Werte dieser</span> <span>Schlüssel</span> <span>sind: die Zeichenkette</span> <code><span>"bar"</span></code><span>,</span> <span>die Zahl</span> <code><span>42</span></code> <span>und die dritte</span> <span>Eigenschaft hat</span> <span>ein anderes Objekt</span> <span>als Wert.</span></span></p>

<pre class="brush: js">var object = {
  foo: "bar",
  age: 42,
  baz: { myProp: 12 },
}</pre>

<h3 id="Auf_Eigenschaften_zugreifen">Auf Eigenschaften zugreifen</h3>

<p>Sobald ein Objekt erzeugt worden ist, möchte man auf seine Eigenschaften lesend oder schreibend zugreifen. Auf die Eigenschaften eines Objektes kann mit der Punktnotation oder der Klammer-Notation zugegriffen werden. Siehe <a href="/de/docs/Web/JavaScript/Reference/Operators/Property_Accessors">Eigenschaftszugriffe</a> für weiter Informationen.</p>

<pre class="brush: js">object.foo; // "bar"
object["age"]; // 42

object.foo = "baz";
</pre>

<h3 id="Eigenschaften_definieren">Eigenschaften definieren</h3>

<p><span id="result_box" lang="de"><span>Wir haben bereits</span> <span>gelernt, wie man</span> <span>Eigenschaften mit Hilfe der</span> <span>Initialisierungs</span> <span>Syntax</span> <span>schreibt</span><span>.</span> <span>Oft</span> <span>gibt es Variablen</span> <span>im </span><span>Code, die</span> <span>Sie in einem Objekt verwenden möchten</span><span>.</span> Man sieht oft Quellcode wie den folgenden: </span></p>

<pre class="brush: js">var a = "foo",
    b = 42,
    c = {};

var o = {
  a: a,
  b: b,
  c: c
};</pre>

<p><span id="result_box" lang="de"><span>Mit</span> <span>ECMAScript</span> 2015 ist <span>eine</span> <span>kürzere</span> <span>Schreibweise</span> <span>verfügbar, um das</span> G<span>leiche zu erreichen</span><span>:</span></span></p>

<pre class="brush: js">var a = "foo",
    b = 42,
    c = {};

// Kurzschreibweise für Eigenschaftsnamen in ES2015
var o = { a, b, c };

// In anderen Worten
console.log(); // true</pre>

<h4 id="Doppelte_Eigenschaftsnamen">Doppelte Eigenschaftsnamen</h4>

<p><span id="result_box" lang="de"><span>Bei Verwendung des</span> <span>gleichen Namens</span> <span>für Ihre</span> <span>Eigenschaften</span><span>, wird die</span> <span>zweite Eigenschaft</span> <span>die erste</span> <span>überschreiben.</span></span></p>

<pre class="brush: js">var a = {x: 1, x: 2};
console.log(a); // { x: 2}
</pre>

<p>Im strikten Modus von ECMAScript 5 wurden doppelte Eigenschaftsnamen als {{jsxref("SyntaxError")}} gewertet. Mit der Einführung von berechneten Eigenschaftsnamen in ECMAScript 2015 wurde diese Einschränkung entfernt, was Duplikate zur Laufzeit möglich macht.</p>

<pre class="brush: js">function haveES2015DuplicatePropertySemantics(){
  "use strict";
  try {
    ({ prop: 1, prop: 2 });

    // No error thrown, duplicate property names allowed in strict mode
    return true;
  } catch (e) {
    // Error thrown, duplicates prohibited in strict mode
    return false;
  }
}</pre>

<h3 id="Methoden_Definitionen">Methoden Definitionen</h3>

<p><span id="result_box" lang="de"><span>Eine</span> <span>Eigenschaft eines Objekts</span> <span>kann auch</span> <span>auf eine <a href="/de/docs/Web/JavaScript/Reference/Functions">Funktion</a></span> <span>oder</span> <span>einen</span> <a href="/de/docs/Web/JavaScript/Reference/Functions/get">Getter</a> <span>oder</span> <span><a href="/de/docs/Web/JavaScript/Reference/Functions/set">Setter</a>-Methode</span> <span>verweisen</span></span>.</p>

<pre class="brush: js">var o = {
  <var>property: function </var>([<var>parameters</var>]) {},
  get <var>property</var>() {},
  set <var>property</var>(<var>value</var>) {},
};</pre>

<p>In ECMAScript 2015 gibt es eine kürzere Schreibweise, mit der das Schlüsselwort "function" überflüssig wird.</p>

<pre class="brush: js">// Kurzschreibweise für Methoden Namen (ES2015)
var o = {
  <var>property</var>([<var>parameters</var>]) {},
  * <var>generator</var>() {}
};</pre>

<p>In ECMAScript 2015 gibt es eine Möglichkeit Eigenschaften mit einer Generatorfunktion zu definierten:</p>

<pre class="brush: js">var o = {
  *generator() {
    ........
  }
};</pre>

<p>Diese ist gleich zur ES5 ähnlichen Notation (aber ECMAScript 5 hat keine Generatorfunktionen):</p>

<pre class="brush: js">var o = {
  generator = function* () {
    ........
  }
}</pre>

<p>Für weitere Informationen und Beispiele zu Methoden, siehe <a href="/de/docs/Web/JavaScript/Reference/Functions/Method_definitions">Methodendefinitionen</a>.</p>

<h3 id="Berechnete_Bezeichnernamen">Berechnete Bezeichnernamen</h3>

<p>Beginnend mit ECMAScript 2015, unterstützt die Objekt Initialisierer Syntax auch berechnete Bezeichnernamen für Objekt Eigenschaften. Das gestatt dem Programmierer einen Ausdruck in eckigen Klammern anzugeben, aus welchem der Bezeichnernamen für die Objekt Eigenschaft berechnet wird. Die Schreibweise dafür ist analog zu der Klammer-Notation für den <a href="/de/docs/Web/JavaScript/Reference/Operators/Property_Accessors">Zugriff auf Objekt Eigenschaften</a> welche Sie bereits benutzt haben. Dieselbe Syntax kann nun für Eigenschaften Bezeichner verwendet werden:</p>

<pre class="brush: js">// Computed property names (ES2015)
var i = 0;
var a = {
  ["foo" + ++i]: i,
  ["foo" + ++i]: i,
  ["foo" + ++i]: i
};

console.log(a.foo1); // 1
console.log(a.foo2); // 2
console.log(a.foo3); // 3

var param = 'size';
var config = {
  [param]: 12,
  ["mobile" + param.charAt(0).toUpperCase() + param.slice(1)]: 4
};

console.log(config); // { size: 12, mobileSize: 4 }</pre>

<h3 id="Spread_Eigenschaften">Spread Eigenschaften</h3>

<p>Die Vorschlag von <a href="https://github.com/tc39/proposal-object-rest-spread">Rest/Spread Eigenschaft für ECMAScript</a> (Stage 4) fügt <a href="/de/docs/Web/JavaScript/Reference/Operators/Spread_operator">Spread</a> Eigenschaften zu Objektliteralen hinzu. Er kopiert eigene aufzählbare Eigenschaften des genutzten Objektes in ein neues Objekt.</p>

<p>Oberflächliches Clonen (ausgenommen Eigenschaften) oder Verschmelzen von Objekten ist nun mit einer Kürzeren Syntax als {{jsxref("Object.assign()")}} möglich.</p>

<pre class="brush: js">var obj1 = { foo: 'bar', x: 42 };
var obj2 = { foo: 'baz', y: 13 };

var clonedObj = { ...obj1 };
// Object { foo: 'bar', x: 42 };

var mergeObj = { ...obj1, ...obj2 };
// Object { foo: 'baz', x: 42, y: 13 }</pre>

<p>Zu beachten ist, dass {{jsxref("Object.assign()")}} <a href="/de/docs/Web/JavaScript/Reference/Functions/set">Setters</a> benutzt, was der Spread Operator nicht macht.</p>

<h3 id="Prototypmutationen">Prototypmutationen</h3>

<p>Eine Eigenschaft Definition der Form <code>__proto__: Wert</code> oder <code>"__proto__": Wert</code> erzeugt keine Eigenschaft mit dem Namen <code>__proto__</code>. Wenn der angegebene Wert ein Objekt oder <code><a href="/de/docs/Web/JavaScript/Reference/Global_Objects/null">null</a></code> ist, wird stattdessen der <code>[[Prototyp]]</code> des erzeugten Objektes auf den angegebenen Wert geändert. (Das Objekt wird nicht verändert, falls der Wert kein Objekt oder null ist.)</p>

<pre class="brush: js">var obj1 = {};
assert(Object.getPrototypeOf(obj1) === Object.prototype);

var obj2 = { __proto__: null };
assert(Object.getPrototypeOf(obj2) === null);

var protoObj = {};
var obj3 = { "__proto__": protoObj };
assert(Object.getPrototypeOf(obj3) === protoObj);

var obj4 = { __proto__: "not an object or null" };
assert(Object.getPrototypeOf(obj4) === Object.prototype);
assert(!obj4.hasOwnProperty("__proto__"));
</pre>

<p>Pro Objekt-Literal ist nur eine einzelne Prototypmutation erlaubt: mehrfache Prototyp Mutationen führen zu einem Syntax Fehler.</p>

<p>Eigenschaftsdefinitionen welche nicht von der Doppelpunkt Notation Gebrauch machen, sind keine Prototyp Mutationen: es sind Eigenschaftsdefinitionen die sich verhalten wie jede andere Definition von Eigenschaftsbezeichnern auch.</p>

<pre class="brush: js">var __proto__ = "variable";

var obj1 = { __proto__ };
assert(Object.getPrototypeOf(obj1) === Object.prototype);
assert(obj1.hasOwnProperty("__proto__"));
assert(obj1.__proto__ === "variable");

var obj2 = { __proto__() { return "hello"; } };
assert(obj2.__proto__() === "hello");

var obj3 = { ["__prot" + "o__"]: 17 };
assert(obj3.__proto__ === 17);
</pre>

<h2 id="Objektliteral-Notation_vs_JSON">Objektliteral-Notation vs JSON</h2>

<p><span id="result_box" lang="de"><span>Die</span> <span>Objekt-Literal</span> <span>Notation ist</span> <span>nicht dasselbe wie</span> <span>die</span> <span>JavaScript Object Notation</span> <span>(</span><span><a href="/de/docs/Glossary/JSON">JSON</a>)</span><span>.</span> <span>Obwohl</span> <span>sie ähnlich aussehen</span><span>, gibt es</span> <span>Unterschiede zwischen ihnen</span></span>:</p>

<ul>
 <li><span id="result_box" lang="de"><span>JSON</span> <span>erlaubt</span> <span>nur</span> <span>Eigenschaftsdefinition</span>en <span>mit</span> <code><span>"Eigenschaft"</span><span>:</span> <span>Wert</span></code> <span>Syntax.</span> <span>Der Eigenschaftsname</span> <span>muss</span> <span>in doppelten Anführungszeichen geschrieben werden</span><span>, und die</span> <span>Definition kann nicht</span> in Kurzschreibweise erfolgen</span>.</li>
 <li><span id="result_box" lang="de"><span>In</span> <span>JSON</span> <span>können die Werte</span> <span>nur</span> <span>Strings, Zahlen</span><span>, Arrays,</span> <span><code>true</code>, <code>false</code></span><span>, <code>null</code></span> <span>oder  andere</span> <span>(</span><span>JSON)</span> <span>Objekte sein</span></span>.</li>
 <li><span id="result_box" lang="de"><span>Ein</span> <span>Funktionswert</span> <span>(siehe</span> <span>"Methoden"</span> <span>oben)</span> <span>kann in JSON keinem Wert zugeordnet werden.</span></span></li>
 <li><span id="result_box" lang="de"><span>Objekte</span> <span>wie {</span><span>{</span><span>jsxref</span> <span>(</span><span>"Date</span><span>")</span><span>}}</span> <span>werden</span> </span><span id="result_box" lang="de"><span>nach dem Aufruf von</span> <span>{</span><span>{</span><span>jsxref</span> <span>(</span><span>"</span><span>JSON.parse</span><span>()")</span><span>}}</span></span><span id="result_box" lang="de">, in <span>einen String</span> <span>umgewandelt</span><span>, </span><span>.</span></span></li>
 <li>{{jsxref("JSON.parse()")}} weist berechnete Eigenschaftsnamen zurück und wirft eine Fehlermeldung.</li>
</ul>

<h2 id="Spezifikationen">Spezifikationen</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Spezifikation</th>
   <th scope="col">Status</th>
   <th scope="col">Kommentar</th>
  </tr>
  <tr>
   <td>{{SpecName('ES1')}}</td>
   <td>{{Spec2('ES1')}}</td>
   <td>Initiale Definition.</td>
  </tr>
  <tr>
   <td>{{SpecName('ES5.1', '#sec-11.1.5', 'Object Initializer')}}</td>
   <td>{{Spec2('ES5.1')}}</td>
   <td><a href="/de/docs/Web/JavaScript/Reference/Functions/get">Getter</a> und <a href="/de/docs/Web/JavaScript/Reference/Functions/set">Setter</a> hinzugefügt.</td>
  </tr>
  <tr>
   <td>{{SpecName('ES2015', '#sec-object-initializer', 'Object Initializer')}}</td>
   <td>{{Spec2('ES2015')}}</td>
   <td>Kurzschreibweise für Methoden-/Eigenschaftsnamen und berechnete Eigenschaftsnamen hinzugefügt.</td>
  </tr>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-object-initializer', 'Object Initializer')}}</td>
   <td>{{Spec2('ESDraft')}}</td>
   <td></td>
  </tr>
  <tr>
   <td><a href="https://github.com/tc39/proposal-object-rest-spread">Rest/Spread Properties for ECMAScript </a></td>
   <td>Entwurf</td>
   <td>Stage 4 (Fertig).</td>
  </tr>
 </tbody>
</table>

<h2 id="Browserkompatibilität">Browserkompatibilität</h2>

<div>


<p>{{Compat("javascript.operators.object_initializer")}}</p>
</div>

<h2 id="See_also" name="See_also">Siehe auch</h2>

<ul>
 <li><a href="/de/docs/Web/JavaScript/Reference/Operators/Property_Accessors">Eigenschaftszugriffe</a></li>
 <li><code><a href="/de/docs/Web/JavaScript/Reference/Functions/get">get</a></code> / <code><a href="/de/docs/Web/JavaScript/Reference/Functions/set">set</a></code></li>
 <li><a href="/de/docs/Web/JavaScript/Reference/Functions/Method_definitions">Methodendefinitionen</a></li>
 <li><a href="/de/docs/Web/JavaScript/Reference/Lexical_grammar">Lexikalische Grammatik</a></li>
</ul>
